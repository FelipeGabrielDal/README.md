<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Parte 2</title>
    <style> 
  body {
    margin: 000;
}

#menu ul{
  margin: 00;
  background-color: #000000;
  list-style: none;

}

#menu ul li {
  display: inline;
}

#menu ul li a {
  padding: 10px 10px;
  display: inline-block;

  color: white;
  text-decoration: none;
}

#menu ul li a:hover{
  color: #00736e;
}
</style>
    
  </head>
  <body>
  	<br>
<body>
    <main>
  	<div id = "menu"> 
        <ul>
          <ul>
          <li><a href = "index.html">VOLTAR AO INICIO</a></li>
          <li><a href = "principais comandos do git.html">COMANDOS DO GIT</a></li>
          <li><a href = "PRINCIPAIS%20COMANDOS%20DE%20UM%20FLOW.html">COMANDOS DO GIT FLOW</a></li>
        </ul>
      </div>


 <h1> Comandos GIT </h1>

<b><p> Estados </p></b>

* Modificado (modified);
* Preparado (staged/index)
* Consolidado (comitted);

<p> <b> Ajuda </b></p>

Geral
	git help
	
<p> <b> Comando específico </b></p>
	git help add
	git help commit
	git help <qualquer_comando_git>
	

<p> <b> Setar usuário</b></p>
	git config --global user.name "Inserir nome"

<p><b>Setar email</b></p>
	git config --global user.email inserir email
	
<p><b> Setar editor </b></p>
	git config --global core.editor vim
	
<p> <b> Setar ferramenta de merge </b></p>
	git config --global merge.tool vimdiff

<p><b>Setar arquivos a serem ignorados </b></p>
	git config --global core.excludesfile ~/.gitignore

<p> <b> Listar configurações </b></p>
	git config --list

<p> <b> Ignorar Arquivos </b></p>

Os nomes de arquivos/diretórios ou extensões de arquivos listados no arquivo **.gitignore** não serão adicionados em um repositório. Existem dois arquivos .gitignore, são eles:

* Geral: Normalmente armazenado no diretório do usuário do Sistema Operacional. O arquivo que possui a lista dos arquivos/diretórios a serem ignorados por **todos os repositórios** deverá ser declarado conforme citado acima. O arquivo não precisa ter o nome de **.gitignore**.

* Por repositório: Deve ser armazenado no diretório do repositório e deve conter a lista dos arquivos/diretórios que devem ser ignorados apenas para o repositório específico.

<p> <b>Repositório Local</b></p>

<p><b> Criar novo repositório </b></p>

	git init

<p> <b> Verificar estado dos arquivos/diretórios </b></p>

	git status

<p> <b> Adicionar arquivo/diretório (staged area) </b></p>

<p><b> Adicionar um arquivo em específico </b></p>>

	git add meu_arquivo.txt

<p><b> Adicionar um diretório em específico</b></p>

	git add meu_diretorio

<p><b> Adicionar todos os arquivos/diretórios</b></p>
	
	git add .	
	
<p><b> Adicionar um arquivo que esta listado no .gitignore (geral ou do repositório)</b></p>
	
	git add -f arquivo_no_gitignore.txt
	
<p><b> Comitar arquivo/diretório</b></p>

<p><b> Comitar um arquivo</b></p>
	
	git commit meu_arquivo.txt

<p><b> Comitar vários arquivos</b></p>

	git commit meu_arquivo.txt meu_outro_arquivo.txt
	
<p><b> Comitar informando mensagem</b></p>

	git commit meuarquivo.txt -m "minha mensagem de commit"

<p><b> Remover arquivo/diretório</b></p>

<p><b> Remover arquivo</b></p>

	git rm meu_arquivo.txt

<p><b> Remover diretório</b></p>

	git rm -r diretorio

<p><b> Visualizar histórico</b></p>

<p><b> Exibir histórico</b></p>
	
	git log
	
<p><b> Exibir histórico com diff das duas últimas alterações</b></p>

	git log -p -2
	
<p><b> Exibir resumo do histórico (hash completa, autor, data, comentário e qtde de alterações (+/-))</b></p>

	git log --stat
	
<p><b> Exibir informações resumidas em uma linha (hash completa e comentário)</b></p>

	git log --pretty=oneline
	
<p><b> Exibir histórico com formatação específica (hash abreviada, autor, data e comentário)</b></p>

	git log --pretty=format:"%h - %an, %ar : %s"
	
* %h: Abreviação do hash;
* %an: Nome do autor;
* %ar: Data;
* %s: Comentário.

Verifique as demais opções de formatação no [Git Book](http://git-scm.com/book/en/Git-Basics-Viewing-the-Commit-History)

<p><b> Exibir histório de um arquivo específico</b></p>

	git log -- <caminho_do_arquivo>

<p><b> Exibir histórico de um arquivo específico que contêm uma determinada palavra</b></p>

	git log --summary -S<palavra> [<caminho_do_arquivo>]

<p><b> Exibir histórico modificação de um arquivo</b></p>

	git log --diff-filter=M -- <caminho_do_arquivo>

* O <D> pode ser substituido por: Adicionado (A), Copiado (C), Apagado (D), Modificado (M), Renomeado (R), entre outros.

<p><b> Exibir histório de um determinado autor</b></p>

	git log --author=usuario

<p><b> Exibir revisão e autor da última modificação de uma bloco de linhas</b></p>

	git blame -L 12,22 meu_arquivo.txt 

<p><b> Desfazendo operações</b></p>

<p><b> Desfazendo alteração local (working directory)</b></p>
Este comando deve ser utilizando enquanto o arquivo não foi adicionado na **staged area**. 

	git checkout -- meu_arquivo.txt

<p><b> Desfazendo alteração local (staging area)</b></p>
Este comando deve ser utilizando quando o arquivo já foi adicionado na **staged area**.

	git reset HEAD meu_arquivo.txt

Se o resultado abaixo for exibido, o comando reset *não* alterou o diretório de trabalho. 

	Unstaged changes after reset:
	M	meu_arquivo.txt

A alteração do diretório pode ser realizada através do comando abaixo:
	
	git checkout meu_arquivo.txt

<p><b> Repositório Remoto</b></p>

<p><b> Exibir os repositórios remotos</b></p>

	git remote
	
	git remote -v

<p><b> Vincular repositório local com um repositório remoto</b></p>

	git remote add origin git@github.com:leocomelli/curso-git.git
	
<p><b> Exibir informações dos repositórios remotos</b></p>

	git remote show origin
	
<p><b> Renomear um repositório remoto </b></p>

	git remote rename origin curso-git
	
<p><b> Desvincular um repositório remoto</b></p>
	
	git remote rm curso-git

<p><b> Enviar arquivos/diretórios para o repositório remoto</b></p>

O primeiro **push** de um repositório deve conter o nome do repositório remoto e o branch.

	git push -u origin master
	
Os demais **pushes** não precisam dessa informação

	git push
	

<p><b> Atualizar repositório local de acordo com o repositório remoto</b></p>

<p><b> Atualizar os arquivos no branch atual</b></p>

	git pull
	
<p><b> Buscar as alterações, mas não aplica-las no branch atual</b></p>

	git fetch
	
<p><b> Clonar um repositório remoto já existente</b></p>

	git clone git@github.com:leocomelli/curso-git.git
	
<p><b> Tags</b></p>

<p><b> Criando uma tag leve</b></p>

	git tag vs-1.1

<p><b> Criando uma tag anotada</b></p>

	git tag -a vs-1.1 -m "Minha versão 1.1"

<p><b> Criando uma tag assinada</b></p>
Para criar uma tag assinada é necessário uma chave privada (GNU Privacy Guard - GPG).

	git tag -s vs-1.1 -m "Minha tag assinada 1.1"

<p><b> Criando tag a partir de um commit (hash)</b></p>

	git tag -a vs-1.2 9fceb02
	
<p><b> Criando tags no repositório remoto</b></p>

	git push origin vs-1.2
	
<p><b> Criando todas as tags locais no repositório remoto</b></p>

	git push origin --tags
	
<p><b> Branches</b></p>

O **master** é o branch principal do GIT.

O **HEAD** é um ponteiro *especial* que indica qual é o branch atual. Por padrão, o **HEAD** aponta para o branch principal, o **master**.

<p><b> Criando um novo branch</b></p>

	git branch bug-123
	
<p><b> Trocando para um branch existente</b></p>

	git checkout bug-123
	
Neste caso, o ponteiro principal **HEAD** esta apontando para o branch chamado bug-123.

<p><b> Criar um novo branch e trocar </b></p>

	git checkout -b bug-456
	
<p><b> Voltar para o branch principal (master)</b></p>

	git checkout master
	
<p><b> Resolver merge entre os branches</b></p>

	git merge bug-123
	
Para realizar o *merge*, é necessário estar no branch que deverá receber as alterações. O *merge* pode automático ou manual. O merge automático será feito em arquivos textos que não sofreram alterações nas mesmas linhas, já o merge manual será feito em arquivos textos que sofreram alterações nas mesmas linhas.

A mensagem indicando um *merge* manual será:

	Automerging meu_arquivo.txt
	CONFLICT (content): Merge conflict in meu_arquivo.txt
	Automatic merge failed; fix conflicts and then commit the result.


<p><b> Apagando um branch</b></p>

	git branch -d bug-123

<p><b> Listar branches </b></p>

<p><b> Listar branches</b></p>

	git branch

<p><b> Listar branches com informações dos últimos commits</b></p>

	git branch -v

<p><b> Listar branches que já foram fundidos (merged) com o **master**</b></p>

	git branch --merged

<p><b> Listar branches que não foram fundidos (merged) com o **master**</b></p>

	git branch --no-merged

<p><b> Criando branches no repositório remoto</b></p>

<p><b> Criando um branch remoto com o mesmo nome</b></p>

	git push origin bug-123

<p><b> Criando um branch remoto com nome diferente</b></p>

	git push origin bug-123:new-branch

<p><b> Baixar um branch remoto para edição</b></p>

	git checkout -b bug-123 origin/bug-123


<p><b>Apagar branch remoto</b></p>

	git push origin:bug-123

<p><b> Rebasing</b></p>

Fazendo o **rebase** entre um o branch bug-123 e o master.

	git checkout experiment
	
	git rebase master
	

Mais informações e explicações sobre o [Rebasing](http://git-scm.com/book/en/Git-Branching-Rebasing)

<p><b> Stash</b></p>

Para alternar entre um branch e outro é necessário fazer o commit das alterações atuais para depois trocar para um outro branch. Se existir a necessidade de realizar a troca sem fazer o commit é possível criar um **stash**. O Stash como se fosse um branch temporário que contem apenas as alterações ainda não commitadas.

<p><b> Criar um stash</b></p>
	
	git stash
	
<p><b> Listar stashes</b></p>

	git stash list

<p><b> Voltar para o último stash</b></p>

	git stash apply

<p><b> Voltar para um stash específico</b></p>
	
	git stash apply stash@{2}
	
Onde **2** é o indíce do stash desejado.

<p><b> Criar um branch a partir de um stash</b></p>

	git stash branch meu_branch

<p><b> Reescrevendo o histórico</b></p>

<p><b> Alterando mensagens de commit</b></p>

	git commit --amend -m "Minha nova mensagem"

<p><b> Alterar últimos commits</b></p>
Alterando os três últimos commits

	git rebase -i HEAD~3

O editor de texto será aberto com as linhas representando os três últimos commits.

	pick f7f3f6d changed my name a bit
	pick 310154e updated README formatting and added blame
	pick a5f4a0d added catfile

Altere para edit os commits que deseja realizar alterações.

	edit f7f3f6d changed my name a bit
	pick 310154e updated README formatting and added blame
	pick a5f4a0d added catfile

Feche o editor de texto.

Digite o comando para alterar a mensagem do commit que foi marcado como *edit*.

	git commit –amend -m “Nova mensagem”

Aplique a alteração

	git rebase --continue

**Atenção:** É possível alterar a ordem dos commits ou remover um commit apenas
mudando as linhas ou removendo.


<p><b> Juntando vários commits</b></p>
Seguir os mesmos passos acima, porém marcar os commtis que devem ser juntados com **squash*
	
<p><b> Remover todo histórico de um arquivo</b></p>

	git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
	
	
<p><b> Bisect</b></p>
O bisect (pesquisa binária) é útil para encontrar um commit que esta gerando um bug ou uma inconsistência entre uma sequência de commits.

<p><b> Iniciar pequinsa binária</b></p>

	git bisect start
	
<p><b> Marcar o commit atual como ruim</b></p>

	git bisect bad

<p><b> Marcar o commit de uma tag que esta sem o bug/inconsistência</b></p>

	git bisect good vs-1.1

<p><b> Marcar o commit como bom</b></p>
O GIT irá navegar entre os commits para ajudar a indentificar o commit que esta com o problema. Se o commit atual não estiver quebrado, então é necessário marca-lo como **bom**.

	git bisect good

<p><b> Marcar o commit como ruim</b></p>
Se o commit estiver com o problema, então ele deverá ser marcado como **ruim**.

 	git bisect bad
 
<p><b> Finalizar a pesquisa binária </b></p>
Depois de encontrar o commit com problema, para retornar para o *HEAD* utilize:
	
	git bisect reset
 

 </br>
	</body>
</html>
